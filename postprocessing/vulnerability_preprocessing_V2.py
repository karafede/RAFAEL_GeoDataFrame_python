
import os

os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing')
os.getcwd()

import numpy as np
import pandas as pd
import geopandas as gpd
from geopandas import GeoDataFrame
from shapely.geometry import Point
import folium
import osmnx as ox
import networkx as nx
import math
import momepy
# from funcs_network_FK import roads_type_folium
from shapely import geometry
from shapely.geometry import Point, Polygon
import psycopg2
# import db_connect
import datetime
import seaborn as sns
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from folium_stuff_FK_map_matching import plot_graph_folium_FK
import glob
from funcs_network_FK import cost_assignment
import statistics
import db_connect
from shapely import wkb
import sqlalchemy as sal

conn_HAIG = db_connect.connect_HAIG_Viasat_CT()
cur_HAIG = conn_HAIG.cursor()

# Function to generate WKB hex
def wkb_hexer(line):
    return line.wkb_hex

# Create an SQL connection engine to the output DB
engine = sal.create_engine('postgresql://postgres:vaxcrio1@localhost:5432/HAIG_Viasat_CT')

os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing')
os.getcwd()

# load grafo for the whole geographical area
# file_graphml = 'Catania__Italy.graphml'
file_graphml = 'Catania__Italy_cost.graphml'
grafo = ox.load_graphml(file_graphml)
# ox.plot_graph(grafo)
place_country = "Catania, Italy"
# cost_assignment(file_graphml, place_country)


# load file containing times and speed, RECORDS and FREQUENCIES from the Database (from the map-matching)
gdf_all_EDGES = pd.read_sql_query(
    ''' SELECT *
        FROM public.paths_postprocess_temp''', conn_HAIG)


## transform Geometry from text to LINESTRING
def wkb_tranformation(line):
   return wkb.loads(line.geom, hex=True)

gdf_all_EDGES['geometry'] = gdf_all_EDGES.apply(wkb_tranformation, axis=1)
gdf_all_EDGES.drop(['geom'], axis=1, inplace= True)

## add "ORIGIN" and "DESTINATION"
## for each idtrajectory....get first (ORIGIN) and last element (DESTINATION) from min(sequence) and max(sequence)
df_origin = gdf_all_EDGES.groupby('idtrajectory').agg({'sequenza': min}).reset_index()
df_origin = pd.merge(df_origin, gdf_all_EDGES, on = ['idtrajectory', 'sequenza'], how = 'left')
df_origin = df_origin[['idtrajectory', 'sequenza', 'u']]
df_destination = gdf_all_EDGES.groupby('idtrajectory').agg({'sequenza': max}).reset_index()
df_destination = pd.merge(df_destination, gdf_all_EDGES, on = ['idtrajectory', 'sequenza'], how = 'left')
df_destination = df_destination[['idtrajectory', 'sequenza', 'v']]
df_origin=df_origin.rename(columns = {'u':'ORIGIN'})
df_destination=df_destination.rename(columns = {'v':'DESTINATION'})
df_destination.drop(['sequenza'], axis=1, inplace= True)
df_origin.drop(['sequenza'], axis=1, inplace= True)

OD = pd.merge(df_origin, df_destination, on=['idtrajectory'], how='left')
gdf_all_EDGES = pd.merge(gdf_all_EDGES,OD, on = ['idtrajectory'], how = 'left')
## drop 'level_0' column
gdf_all_EDGES.drop(['level_0'], axis=1, inplace = True)
gdf_all_EDGES = gpd.GeoDataFrame(gdf_all_EDGES)
gdf_all_EDGES.plot()


## get only selected "highway fields":
AAA = pd.DataFrame(gdf_all_EDGES)
# gdf_all_EDGES = gdf_all_EDGES[gdf_all_EDGES['highway'].isin(['motorway', 'motorway_link', 'primary', 'trunk',
#                                                                 'trunk_link', 'road', 'primary_link',
#                                                                 'secondary', 'secondary_link'])]

# save file as .GeoJSON
gdf_all_EDGES.to_file(filename='TIME_EDGES_DB.geojson', driver='GeoJSON')

os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing')

# make attr "cost" as float!!! (units of "cost" are SECONDS!)
for u, v, key, attr in grafo.edges(keys=True, data=True):
    if len(attr['cost']) >0:
        attr['cost'] = float(attr.get("cost"))


########################################################################################
## replace "cost" with "travel time" got from VIASAT analysis for  given u,v pair ######
########################################################################################
#### LONG TIME RUNNING #################################################################

for U, V, key, attr in grafo.edges(keys=True, data=True):
    # print(attr["cost"])
    attr['VIASAT_cost'] = attr.get("cost")
    zipped = zip(list(gdf_all_EDGES.u), list(gdf_all_EDGES.v)) # we should use TIME_EDGES....
    if (U,V) in zipped:
        travel_time = gdf_all_EDGES[(gdf_all_EDGES.u == U) &
                                             (gdf_all_EDGES.v == V)]['travel_time_secs']  # in seconds
        print(float(travel_time))
        attr['VIASAT_cost'] = float(travel_time)
        grafo.add_edge(U, V, key, attr_dict=attr)
ox.save_graphml(grafo, filename= 'CATANIA_VIASAT_cost.graphml')


# change directory
os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing\\vulnerability')


# define distance between two coordinates
def haversine(coord1, coord2):
    # Coordinates in decimal degrees (e.g. 43.60, -79.49)
    lon1, lat1 = coord1
    lon2, lat2 = coord2
    R = 6371000  # radius of Earth in meters
    phi_1 = np.radians(lat1)
    phi_2 = np.radians(lat2)
    delta_phi = np.radians(lat2 - lat1)
    delta_lambda = np.radians(lon2 - lon1)
    a = np.sin(delta_phi / 2.0) ** 2 + np.cos(phi_1) * np.cos(phi_2) * np.sin(delta_lambda / 2.0) ** 2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
    meters = R * c  # output distance in meters
    km = meters / 1000.0  # output distance in kilometers
    meters = round(meters)
    km = round(km, 3)
    # print(f"Distance: {meters} m")
    # print(f"Distance: {km} km")
    return meters


# define the extension of the EDGE file
xmin, ymin, xmax, ymax = gdf_all_EDGES.total_bounds  # lat-long of 2 corners
# East-West extent of Toronto = 42193 metres
EW = haversine((xmin, ymin), (xmax, ymin))
# North-South extent of Toronto = 30519 metres
NS = haversine((xmin, ymin), (xmin, ymax))
# diamter of each hexagon in the grid = 900 metres
d = 1800
# horizontal width of hexagon = w = d* sin(60)
w = d * np.sin(np.pi / 3)
# Approximate number of hexagons per row = EW/w
n_cols = int(EW / w) + 1
# Approximate number of hexagons per column = NS/d
n_rows = int(NS / d) + 10

# Make a hexagonal grid to cover the entire area
from matplotlib.patches import RegularPolygon

ax = gdf_all_EDGES.boundary.plot(edgecolor='black', figsize=(20, 60))
w = (xmax - xmin) / n_cols  # width of hexagon
d = w / np.sin(np.pi / 3)  # diameter of hexagon
array_of_hexes = []
for rows in range(0, n_rows):
    hcoord = np.arange(xmin, xmax, w) + (rows % 2) * w / 2
    vcoord = [ymax - rows * d * 0.75] * n_cols
    for x, y in zip(hcoord, vcoord):  # , colors):
        hexes = RegularPolygon((x, y), numVertices=6, radius=d / 2, alpha=0.2, edgecolor='k')
        verts = hexes.get_path().vertices
        trans = hexes.get_patch_transform()
        points = trans.transform(verts)
        array_of_hexes.append(Polygon(points))
        ax.add_patch(hexes)
ax.set_xlim([xmin, xmax])
ax.set_ylim([ymin, ymax])

hex_grid = gpd.GeoDataFrame({'geometry': array_of_hexes}, crs={'init': 'epsg:4326'})
# hex_grid.plot()


#############################################################################################
# create basemap
ave_LAT = 37.53988692816245
ave_LON = 15.044971594798902
my_map = folium.Map([ave_LAT, ave_LON], zoom_start=11, tiles='cartodbpositron')
#############################################################################################

# get hexagons containing the edges
## rename "index" column into "indice"
gdf_all_EDGES=gdf_all_EDGES.rename(columns = {'index':'indice'})
egdes_hex = gpd.sjoin(hex_grid, gdf_all_EDGES, how='inner', op='intersects')
# egdes_hex.plot()
egdes_hex.geometry.to_file(filename='egdes_hex.geojson', driver='GeoJSON')
hex_grid.geometry.to_file(filename='hex_grid_DB.geojson', driver='GeoJSON')

egdes_hex.reset_index(level=0, inplace=True)
hex_grid.reset_index(inplace=True)

style_hex = {'fillColor': '#00000000', 'color': '#00FFFFFF'}
style_edges = {'fillColor': '#00000000', 'color': '#000000'}
style_egdes_hex = {'fillColor': '#00000000', 'color': '#ff0000'}

os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing')
folium.GeoJson('TIME_EDGES_DB.geojson', style_function=lambda x: style_edges).add_to((my_map))

# add 'u' and 'v' as highligths for each edge (in blue)
folium.GeoJson(
    # data to plot
    hex_grid[['index', 'geometry']].to_json(),
    show=True,
    style_function=lambda x: style_hex,
    highlight_function=lambda x: {'weight': 1,
                                  'color': 'yellow',
                                  'fillOpacity': 0.2
                                  },
    # fields to show
    tooltip=folium.features.GeoJsonTooltip(
        fields=['index']
    ),
).add_to(my_map)

folium.GeoJson(
    # data to plot
    egdes_hex[['index', 'geometry']].to_json(),
    show=True,
    style_function=lambda x: style_egdes_hex,
    highlight_function=lambda x: {'weight': 1,
                                  'color': 'yellow',
                                  'fillOpacity': 0.2
                                  },
    # fields to show
    tooltip=folium.features.GeoJsonTooltip(
        fields=['index']
    ),
).add_to(my_map)

os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing\\vulnerability')
my_map.save("hex_grid_DB.html")



###########################################################
#### save all the elements into a dictionary  #############
###########################################################

elements = {}

# get elements (all edges) within each hexagonal cell)
for idx in range(len(hex_grid)):
    print(idx)
    hex_grid_idx = hex_grid[hex_grid.index.isin([idx])]  # select one cells by time
    for cells in hex_grid_idx.itertuples(index=True):
        edges = []
        index_elements = []
        index_cells = []
        for links in gdf_all_EDGES.itertuples(index=True):
            if links.geometry.intersects(cells.geometry) is True:
                print("OK=========================================================================IN")
                index_elements.append(links.Index)
                index_cells.append(cells.Index)
                STREET = links.u, links.v
                edges.append(STREET)
                # elements[cells.Index] = edges
    gdf_elements = gdf_all_EDGES[gdf_all_EDGES.index.isin(index_elements)]
    if len(gdf_elements) > 0:
        elements[cells.Index] = gdf_elements
        # gdf_elements.plot()

import numpy as np
# Save
np.save('elements_DB.npy', elements)

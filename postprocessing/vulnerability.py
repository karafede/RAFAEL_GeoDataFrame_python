
import os
os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing')
os.getcwd()

import numpy as np
import pandas as pd
import geopandas as gpd
from geopandas import GeoDataFrame
from shapely.geometry import Point
import folium
import osmnx as ox
import networkx as nx
import math
import momepy
# from funcs_network_FK import roads_type_folium
from shapely import geometry
from shapely.geometry import Point, Polygon
import psycopg2
# import db_connect
import datetime
import seaborn as sns
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from folium_stuff_FK_map_matching import plot_graph_folium_FK


####################################################
#### overlay Hexagonal grid  #######################

# https://medium.com/@navaneeth.mohan94/how-to-create-a-hex-map-in-python-3f84602edb14

# load all EDGES obtained from the map-matching algorithm
final_EDGES_CATANIA = gpd.read_file("TIME_EDGES.geojson")
final_EDGES_CATANIA.plot()

def haversine(coord1, coord2):
    # Coordinates in decimal degrees (e.g. 43.60, -79.49)
    lon1, lat1 = coord1
    lon2, lat2 = coord2
    R = 6371000  # radius of Earth in meters
    phi_1 = np.radians(lat1)
    phi_2 = np.radians(lat2)
    delta_phi = np.radians(lat2 - lat1)
    delta_lambda = np.radians(lon2 - lon1)
    a = np.sin(delta_phi / 2.0) ** 2 + np.cos(phi_1) * np.cos(phi_2) * np.sin(delta_lambda / 2.0) ** 2
    c = 2 * np.arctan2(np.sqrt(a),np.sqrt(1 - a))
    meters = R * c  # output distance in meters
    km = meters / 1000.0  # output distance in kilometers
    meters = round(meters)
    km = round(km, 3)
    #print(f"Distance: {meters} m")
    #print(f"Distance: {km} km")
    return meters


xmin,ymin,xmax,ymax = final_EDGES_CATANIA.total_bounds # lat-long of 2 corners
#East-West extent of Toronto = 42193 metres
EW = haversine((xmin,ymin),(xmax,ymin))
# North-South extent of Toronto = 30519 metres
NS = haversine((xmin,ymin),(xmin,ymax))
# diamter of each hexagon in the grid = 900 metres
d = 900
# horizontal width of hexagon = w = d* sin(60)
w = d*np.sin(np.pi/3)
# Approximate number of hexagons per row = EW/w
n_cols = int(EW/w)+1
# Approximate number of hexagons per column = NS/d
n_rows = int(NS/d)+ 10

# Make a hexagonal grid to cover the entire area
from matplotlib.patches import RegularPolygon

ax = final_EDGES_CATANIA.boundary.plot(edgecolor='black',figsize=(20,60))
w = (xmax-xmin)/n_cols # width of hexagon
d = w/np.sin(np.pi/3) #diameter of hexagon
array_of_hexes = []
for rows in range(0,n_rows):
    hcoord = np.arange(xmin,xmax,w) + (rows%2)*w/2
    vcoord = [ymax- rows*d*0.75]*n_cols
    for x, y in zip(hcoord, vcoord):#, colors):
        hexes = RegularPolygon((x, y), numVertices=6, radius=d/2, alpha=0.2, edgecolor='k')
        verts = hexes.get_path().vertices
        trans = hexes.get_patch_transform()
        points = trans.transform(verts)
        array_of_hexes.append(Polygon(points))
        ax.add_patch(hexes)
ax.set_xlim([xmin, xmax])
ax.set_ylim([ymin, ymax])


hex_grid = gpd.GeoDataFrame({'geometry':array_of_hexes},crs={'init':'epsg:4326'})
# hex_grid = gpd.GeoDataFrame({'geometry':array_of_hexes},crs={'init':'epsg:3035'})
# hex_grid.plot()


#############################################################################################
# create basemap
ave_LAT = 37.53988692816245
ave_LON = 15.044971594798902
my_map = folium.Map([ave_LAT, ave_LON], zoom_start=11, tiles='cartodbpositron')
#############################################################################################

# get hexagons containing the eges
egdes_hex = gpd.sjoin(hex_grid, final_EDGES_CATANIA, how='inner', op='intersects')
egdes_hex.plot()
egdes_hex.geometry.to_file(filename='egdes_hex.geojson', driver='GeoJSON')
hex_grid.geometry.to_file(filename='hex_grid.geojson', driver='GeoJSON')

egdes_hex.reset_index(level=0, inplace=True)
hex_grid.reset_index(inplace=True)

style_hex = {'fillColor': '#00000000', 'color': '#00FFFFFF'}
style_edges = {'fillColor': '#00000000', 'color': '#000000'}
style_egdes_hex = {'fillColor': '#ff0000', 'color': '#ff0000'}

folium.GeoJson('TIME_EDGES.geojson',  style_function=lambda x: style_edges).add_to((my_map))
# folium.GeoJson('hex_grid.geojson',  style_function=lambda x: style_hex).add_to((my_map))
# folium.GeoJson('egdes_hex.geojson',  style_function=lambda x: style_egdes_hex).add_to((my_map))

# add 'u' and 'v' as highligths for each edge (in blue)
folium.GeoJson(
    # data to plot
    hex_grid[['index', 'geometry']].to_json(),
    show=True,
    style_function=lambda x:style_hex,
    highlight_function=lambda x: {'weight':3,
        'color':'yellow',
        'fillOpacity':1
    },
    # fields to show
    tooltip=folium.features.GeoJsonTooltip(
        fields=['index']
    ),
).add_to(my_map)


folium.GeoJson(
    # data to plot
    egdes_hex[['index', 'geometry']].to_json(),
    show=True,
    style_function=lambda x:style_egdes_hex,
    highlight_function=lambda x: {'weight':3,
        'color':'yellow',
        'fillOpacity':1
    },
    # fields to show
    tooltip=folium.features.GeoJsonTooltip(
        fields=['index']
    ),
).add_to(my_map)

my_map.save("hex_grid.html")





'''
###########################################
## get edges inside each hexagon ##########

# find all edges intersected by the hexagonal grid
cells = []
index_edges = []
index_cells = []
edge = []

# https://gis.stackexchange.com/questions/344983/line-and-polygon-intersection-in-geopandas-python

for links in final_EDGES_CATANIA.itertuples(index=True):
    for cells in hex_grid.itertuples(index=True):
        if links.geometry.intersects(cells.geometry) is True:
            print("OK==================================IN")
        else:
            print("NOT====IN")
            index_edges.append(links.Index)
            index_cells.append(cells.Index)
            STREET = links.u, links.v, cells.Index
            edge.append(STREET)

## filter gdf_edges based on index_edges (edges in the buffer)
## near neighbour edges (near the viasat measurements)
hex_gdf_edges = hex_grid[hex_grid.index.isin(index_cells)]
hex_grid.plot()
hex_gdf_edges.plot()


## make index as column
hex_gdf_edges.reset_index(inplace=True)
hex_grid.reset_index(inplace=True)


#############################################################################################
# create basemap
ave_LAT = 37.53988692816245
ave_LON = 15.044971594798902
my_map = folium.Map([ave_LAT, ave_LON], zoom_start=11, tiles='cartodbpositron')
#############################################################################################



style_edge = {'fillColor': '#00000000', 'color': '#00FFFFFF'}
# add 'u' and 'v' as highligths for each edge (in blue)
folium.GeoJson(
    # data to plot
    hex_gdf_edges[['index', 'geometry']].to_json(),
    show=True,
    style_function=lambda x:style_edge,
    highlight_function=lambda x: {'weight':3,
        'color':'red',
        'fillOpacity':1
    },
    # fields to show
    tooltip=folium.features.GeoJsonTooltip(
        fields=['index']
    ),
).add_to(my_map)

# hex_gdf_edges = final_EDGES_CATANIA[final_EDGES_CATANIA.index.isin([603])]
## plot selects edges
hex_gdf_edges.plot()

'''

# load grafo of all Catania
file_graphml = 'Catania__Italy.graphml'
grafo = ox.load_graphml(file_graphml)
ox.plot_graph(grafo)
# get edges and nodes
gdf_nodes, gdf_edges = ox.graph_to_gdfs(grafo)
# save edges as GeoJson file
# gdf_edges.to_file(filename='Catania_edges_60km.geojson', driver='GeoJSON')
gdf_edges.to_csv('Catania_edges_60km.csv')


import os

os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing')
os.getcwd()

import numpy as np
import pandas as pd
import geopandas as gpd
from geopandas import GeoDataFrame
from shapely.geometry import Point
import folium
import osmnx as ox
import networkx as nx
import math
import momepy
# from funcs_network_FK import roads_type_folium
from shapely import geometry
from shapely.geometry import Point, Polygon
import psycopg2
# import db_connect
import datetime
import seaborn as sns
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from folium_stuff_FK_map_matching import plot_graph_folium_FK
import glob
from funcs_network_FK import cost_assignment


# load grafo
# file_graphml = 'Catania__Italy.graphml'
file_graphml = 'Catania__Italy_cost.graphml'
grafo = ox.load_graphml(file_graphml)
# ox.plot_graph(grafo)
place_country = "Catania, Italy"
# cost_assignment(file_graphml, place_country)


####################################################
#### overlay Hexagonal grid  #######################

# https://medium.com/@navaneeth.mohan94/how-to-create-a-hex-map-in-python-3f84602edb14

os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing')
# load all EDGES obtained from the map-matching algorithm
final_EDGES_CATANIA = gpd.read_file("TIME_EDGES.geojson")
# final_EDGES_CATANIA.plot()

# change directory
os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing\\vulnerability')


# define distance between two coordinates
def haversine(coord1, coord2):
    # Coordinates in decimal degrees (e.g. 43.60, -79.49)
    lon1, lat1 = coord1
    lon2, lat2 = coord2
    R = 6371000  # radius of Earth in meters
    phi_1 = np.radians(lat1)
    phi_2 = np.radians(lat2)
    delta_phi = np.radians(lat2 - lat1)
    delta_lambda = np.radians(lon2 - lon1)
    a = np.sin(delta_phi / 2.0) ** 2 + np.cos(phi_1) * np.cos(phi_2) * np.sin(delta_lambda / 2.0) ** 2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
    meters = R * c  # output distance in meters
    km = meters / 1000.0  # output distance in kilometers
    meters = round(meters)
    km = round(km, 3)
    # print(f"Distance: {meters} m")
    # print(f"Distance: {km} km")
    return meters


# define the extension of the EDGE file
xmin, ymin, xmax, ymax = final_EDGES_CATANIA.total_bounds  # lat-long of 2 corners
# East-West extent of Toronto = 42193 metres
EW = haversine((xmin, ymin), (xmax, ymin))
# North-South extent of Toronto = 30519 metres
NS = haversine((xmin, ymin), (xmin, ymax))
# diamter of each hexagon in the grid = 900 metres
d = 900
# horizontal width of hexagon = w = d* sin(60)
w = d * np.sin(np.pi / 3)
# Approximate number of hexagons per row = EW/w
n_cols = int(EW / w) + 1
# Approximate number of hexagons per column = NS/d
n_rows = int(NS / d) + 10

# Make a hexagonal grid to cover the entire area
from matplotlib.patches import RegularPolygon

ax = final_EDGES_CATANIA.boundary.plot(edgecolor='black', figsize=(20, 60))
w = (xmax - xmin) / n_cols  # width of hexagon
d = w / np.sin(np.pi / 3)  # diameter of hexagon
array_of_hexes = []
for rows in range(0, n_rows):
    hcoord = np.arange(xmin, xmax, w) + (rows % 2) * w / 2
    vcoord = [ymax - rows * d * 0.75] * n_cols
    for x, y in zip(hcoord, vcoord):  # , colors):
        hexes = RegularPolygon((x, y), numVertices=6, radius=d / 2, alpha=0.2, edgecolor='k')
        verts = hexes.get_path().vertices
        trans = hexes.get_patch_transform()
        points = trans.transform(verts)
        array_of_hexes.append(Polygon(points))
        ax.add_patch(hexes)
ax.set_xlim([xmin, xmax])
ax.set_ylim([ymin, ymax])

hex_grid = gpd.GeoDataFrame({'geometry': array_of_hexes}, crs={'init': 'epsg:4326'})
# hex_grid = gpd.GeoDataFrame({'geometry':array_of_hexes},crs={'init':'epsg:3035'})
# hex_grid.plot()


#############################################################################################
# create basemap
ave_LAT = 37.53988692816245
ave_LON = 15.044971594798902
my_map = folium.Map([ave_LAT, ave_LON], zoom_start=11, tiles='cartodbpositron')
#############################################################################################

# get hexagons containing the edges
egdes_hex = gpd.sjoin(hex_grid, final_EDGES_CATANIA, how='inner', op='intersects')
# egdes_hex.plot()
egdes_hex.geometry.to_file(filename='egdes_hex.geojson', driver='GeoJSON')
hex_grid.geometry.to_file(filename='hex_grid.geojson', driver='GeoJSON')

egdes_hex.reset_index(level=0, inplace=True)
hex_grid.reset_index(inplace=True)

style_hex = {'fillColor': '#00000000', 'color': '#00FFFFFF'}
style_edges = {'fillColor': '#00000000', 'color': '#000000'}
style_egdes_hex = {'fillColor': '#00000000', 'color': '#ff0000'}

os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing')
folium.GeoJson('TIME_EDGES.geojson', style_function=lambda x: style_edges).add_to((my_map))
# folium.GeoJson('hex_grid.geojson',  style_function=lambda x: style_hex).add_to((my_map))
# folium.GeoJson('egdes_hex.geojson',  style_function=lambda x: style_egdes_hex).add_to((my_map))

# add 'u' and 'v' as highligths for each edge (in blue)
folium.GeoJson(
    # data to plot
    hex_grid[['index', 'geometry']].to_json(),
    show=True,
    style_function=lambda x: style_hex,
    highlight_function=lambda x: {'weight': 1,
                                  'color': 'yellow',
                                  'fillOpacity': 0.2
                                  },
    # fields to show
    tooltip=folium.features.GeoJsonTooltip(
        fields=['index']
    ),
).add_to(my_map)

folium.GeoJson(
    # data to plot
    egdes_hex[['index', 'geometry']].to_json(),
    show=True,
    style_function=lambda x: style_egdes_hex,
    highlight_function=lambda x: {'weight': 1,
                                  'color': 'yellow',
                                  'fillOpacity': 0.2
                                  },
    # fields to show
    tooltip=folium.features.GeoJsonTooltip(
        fields=['index']
    ),
).add_to(my_map)

os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing\\vulnerability')
my_map.save("hex_grid.html")

##############################################################################################
##############################################################################################
###### ORIGIN - DESTINATION TRIPS ############################################################


# os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing\\new_geojsons')
# extension = 'geojson'
# all_filenames = [i for i in glob.glob('*.{}'.format(extension))]
# # combine all files in the list
# gdf_all_EDGES = pd.concat([gpd.read_file(f) for f in all_filenames])

# change directory
os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing')

# load TIME_EDGES file
TIME_EDGES = gpd.read_file("TIME_EDGES.geojson")


## get all trips between unique ORIGIN and DESTINATION
i = 500
# for i in range(len(TIME_EDGES)):
O = TIME_EDGES.ORIGIN.iloc[i]
D = TIME_EDGES.DESTINATION.iloc[i]
# print('ORIGIN:', O, 'DESTINATION:', D, '================================================')
all_trips = TIME_EDGES[(TIME_EDGES['ORIGIN'] == O) & (TIME_EDGES['DESTINATION'] == D)]
all_trips.plot()
# TRIPS_OD = pd.DataFrame(all_trips)

###########################################
## get edges inside each hexagon ##########

# change directory
os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing\\vulnerability')
# load hex_grid
hex_grid = gpd.read_file("hex_grid.geojson")

# find all edges (links) intersected by the hexagonal grid
## 'links' are the edges (u, v)
## an 'element' is the ensemble of links within a cell or intersecting a cell

# index_elements = []
# index_cells = []
# save all the elements into a dictionary
elements = {}

# TIME_EDGES = TIME_EDGES[0:10]9
# hex_grid = hex_grid[hex_grid.index == 3170]  # select only one particular cell
hex_grid = hex_grid[hex_grid.index.isin([2359, 2290])]  # select two particular cells
for cells in hex_grid.itertuples(index=True):
    edges = []
    index_elements = []
    index_cells = []
    for links in TIME_EDGES.itertuples(index=True):
        if links.geometry.intersects(cells.geometry) is True:
            print("OK=========================================================================IN")
            index_elements.append(links.Index)
            index_cells.append(cells.Index)
            STREET = links.u, links.v
            edges.append(STREET)
            elements[cells.Index] = edges
        else:
            print("NOT====IN")


## filter gdf_edges based on index_edges (edges in the cell)
gdf_elements = TIME_EDGES[TIME_EDGES.index.isin(index_elements)]
# save as GeoJson file
gdf_elements.to_file(filename='gdf_elements.geojson', driver='GeoJSON')
gdf_elements.plot()
# single exagon (cell)
hex_gdf_edges = hex_grid[hex_grid.index.isin(index_cells)]
hex_grid.plot()

## make index as column
hex_gdf_edges.reset_index(inplace=True)
hex_grid.reset_index(inplace=True)

#############################################################################################
# create basemap
ave_LAT = 37.53988692816245
ave_LON = 15.044971594798902
my_map = folium.Map([ave_LAT, ave_LON], zoom_start=11, tiles='cartodbpositron')
#############################################################################################

folium.GeoJson('gdf_elements.geojson', style_function=lambda x: style_edges).add_to((my_map))

style_edge = {'fillColor': '#00000000', 'color': '#ff0000'}
# add 'u' and 'v' as highligths for each edge (in blue)
folium.GeoJson(
    # data to plot
    hex_gdf_edges[['index', 'geometry']].to_json(),
    show=True,
    style_function=lambda x: style_edge,
    highlight_function=lambda x: {'weight': 1,
                                  'color': 'red',
                                  'fillOpacity': 1
                                  },
    # fields to show
    tooltip=folium.features.GeoJsonTooltip(
        fields=['index']
    ),
).add_to(my_map)

## save map
my_map.save("elements_and_links.html")


'''
# load grafo of all Catania
file_graphml = 'Catania__Italy.graphml'
grafo = ox.load_graphml(file_graphml)
ox.plot_graph(grafo)
# get edges and nodes
gdf_nodes, gdf_edges = ox.graph_to_gdfs(grafo)
# save edges as GeoJson file
# gdf_edges.to_file(filename='Catania_edges_60km.geojson', driver='GeoJSON')
gdf_edges.to_csv('Catania_edges_60km.csv')
'''

###################################################################################
## calculate the initial travel timeS and shortest paths between the OD pairs #####
###################################################################################

# for key in list(elements.keys()):
#     print(elements[key])

gdf_elements = TIME_EDGES[TIME_EDGES.index.isin(index_elements)]
OD = gdf_elements.drop_duplicates(['ORIGIN', 'DESTINATION'])
len(OD)
OD.reset_index(level=0, inplace=True)
# select one OD pair
i = 1
O = OD.ORIGIN.iloc[i]
D = OD.DESTINATION.iloc[i]
# print('ORIGIN:', O, 'DESTINATION:', D, '================================================')
all_trips_OD = TIME_EDGES[(TIME_EDGES['ORIGIN'] == O) & (TIME_EDGES['DESTINATION'] == D)]
all_trips_OD.plot()
all_trips_OD.geometry.to_file(filename='all_trips_OD.geojson', driver='GeoJSON')

# #############################################################################################
# # create basemap
# ave_LAT = 37.53988692816245
# ave_LON = 15.044971594798902
# my_map = folium.Map([ave_LAT, ave_LON], zoom_start=11, tiles='cartodbpositron')
# #############################################################################################
#
# folium.GeoJson('all_trips_OD.geojson', style_function=lambda x: style_edges).add_to((my_map))
# ## save map
# my_map.save("all_trips_OD.html")

AAA = pd.DataFrame(OD)
TRIPS_OD = pd.DataFrame(all_trips_OD)

# init_OD_travel_time = sum(all_trips_OD['travel time (min)'])   # not good!!
### Initial OD shortest path
init_shortest_OD_path = nx.shortest_path(grafo, O, D, weight='length') # using length
path_OD_edges = list(zip(init_shortest_OD_path, init_shortest_OD_path[1:]))
# ox.plot_graph_route(grafo, init_shortest_OD_path, route_color='green', fig_height=12, fig_width=12)
path = ox.plot_route_folium(grafo, init_shortest_OD_path, route_color='green')
path.save('OD_shortest_path.html')
## isolate edges in the grafo from 'path_OD_edges'
if len(path_OD_edges) > 1:
    # isolate edges in the grafo from 'all_matched_edges'
    df_nodes = []
    for i in range(len(path_OD_edges)):
        # print(path_OD_edges[i])
        route = path_OD_edges[i]
        df_nodes.append(route)

    df_nodes = pd.DataFrame(df_nodes)
    df_nodes.columns = ['u', 'v']

    # filter gdf_edges with df_nodes
    keys = list(df_nodes.columns.values)
    index_TIME_EDGES = TIME_EDGES.set_index(keys).index
    index_df_nodes = df_nodes.set_index(keys).index
    edges_matched_route_OD = TIME_EDGES[index_TIME_EDGES.isin(index_df_nodes)]
    edges_matched_route_OD.plot()
    edges_matched_route_OD.geometry.to_file(filename='edges_matched_route_OD.geojson', driver='GeoJSON')

    ########################################################
    ### Initial OD shortest TIME (based on VIASAT data #####
    ########################################################
    init_OD_travel_time = sum(edges_matched_route_OD['travel time (sec)'])


   # create basemap
    ave_LAT = 37.53988692816245
    ave_LON = 15.044971594798902
    my_map = folium.Map([ave_LAT, ave_LON], zoom_start=11, tiles='cartodbpositron')
    #############################################################################################

    folium.GeoJson('edges_matched_route_OD.geojson', style_function=lambda x: style_edges).add_to((my_map))
    ## save map
    my_map.save("edges_matched_route_OD.html")


os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing')

# load grafo
file_graphml = 'Catania__Italy_cost.graphml'
grafo = ox.load_graphml(file_graphml)
# ox.plot_graph(grafo)

# make attr "cost" as float!!! (units of "cost" are SECONDS!)
for u, v, key, attr in grafo.edges(keys=True, data=True):
    if len(attr['cost']) >0:
        attr['cost'] = float(attr.get("cost"))


########################################################################################
## replace "cost" with "travel time" got from VIASAT analysis for  given u,v pair ######
########################################################################################

for U, V, key, attr in grafo.edges(keys=True, data=True):
    # print(attr["cost"])
    attr['VIASAT_cost'] = attr.get("cost")
    zipped = zip(list(TIME_EDGES.u), list(TIME_EDGES.v)) # we should use TIME_EDGES....
    if (U,V) in zipped:
        travel_time = TIME_EDGES[(TIME_EDGES.u == U) &
                                             (TIME_EDGES.v == V)]['travel time (sec)']  # in seconds
        print(float(travel_time))
        attr['VIASAT_cost'] = float(travel_time)
        grafo.add_edge(U, V, key, attr_dict=attr)

    # if U in list(edges_matched_route_OD.u) and V in list(edges_matched_route_OD.v):   # we should use TIME_EDGES....
    #     # print(U, V)
    #     # get cost from the TIME_EDGES files obtained from VIASAT data analysis (that time is in minutes)
    #     travel_time = edges_matched_route_OD[ (edges_matched_route_OD.u == U) &
    #                         (edges_matched_route_OD.v == V)]['travel time (sec)']*60 # in seconds
    #     if len(travel_time) > 0:
    #         attr['VIASAT_cost'] = float(travel_time)
    #         # attr['VIASAT_cost'] = -999
    #         # print(attr['VIASAT_cost'])
    #         print("OK==================")
    #         # break
    #         grafo.add_edge(U, V, key, attr_dict=attr)
ox.save_graphml(grafo, filename= 'CATANIA_VIASAT_cost.graphml')

###########################################################################################################
###########################################################################################################
# create basemap
ave_LAT = 37.53988692816245
ave_LON = 15.044971594798902
my_map = folium.Map([ave_LAT, ave_LON], zoom_start=8.5, tiles='cartodbpositron')
###########################################################################################################
###########################################################################################################

os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing')

file_graphml = 'CATANIA_VIASAT_cost.graphml'
grafo = ox.load_graphml(file_graphml)
# check...
# for U, V, key, attr in grafo.edges(keys=True, data=True):
#     if float(attr["VIASAT_cost"]) == 150.0:
#         print(attr["VIASAT_cost"])
#         print("OK===============")


# make attr "cost" as float!!! (units of "cost" are SECONDS!)
for u, v, key, attr in grafo.edges(keys=True, data=True):
    if len(attr['VIASAT_cost']) > 0:
        attr['VIASAT_cost'] = float(attr.get("VIASAT_cost"))
    if len(attr['cost']) >0:
        attr['cost'] = float(attr.get("cost"))

# change directory
os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing\\vulnerability')

init_shortest_OD_path = nx.shortest_path(grafo, O, D, weight='length')  # using cost (time)
path = ox.plot_route_folium(grafo, init_shortest_OD_path, route_color='green')
path_edges = list(zip(init_shortest_OD_path,init_shortest_OD_path[1:]))
lr = nx.shortest_path_length(grafo, O,D, weight='cost')
lunghezza=[]
for l in path_edges:
  lunghezza.append(grafo [l[0]] [l[1]] [0]['length'])  # get only the length for each arch between 2 path edges, [0] it the key = 0
print("km:{0:.3f} h:{1:.3f} vm:{2:.0f}".format(sum(lunghezza)/1000, lr/3600, sum(lunghezza)/1000/lr*3600))  # units == km
path.save('OD_shortest_path_length.html')

## find shortest path based on the "cost" (time)
init_shortest_OD_path_cost = nx.shortest_path(grafo, O, D, weight='cost')  # using cost (time)
path_cost = ox.plot_route_folium(grafo, init_shortest_OD_path_cost, route_color='green')
path_edges = list(zip(init_shortest_OD_path,init_shortest_OD_path_cost[1:]))
lr = nx.shortest_path_length(grafo, O,D, weight='cost')
lunghezza=[]
for l in path_edges:
  lunghezza.append(grafo [l[0]] [l[1]] [0]['length'])  # get only the length for each arch between 2 path edges, [0] it the key = 0
print("km:{0:.3f} h:{1:.3f} vm:{2:.0f}".format(sum(lunghezza)/1000, lr/3600, sum(lunghezza)/1000/lr*3600))  # units == km
path_cost.save('OD_shortest_path_cost.html')

# add shortest path (by "cost" to the my_map
df_nodes = pd.DataFrame(path_edges)
df_nodes.columns = ['u', 'v']

# filter 'TIME_EDGES' with 'df_nodes'
keys = list(df_nodes.columns.values)
index_gdf_edges = TIME_EDGES.set_index(keys).index
index_df_nodes = df_nodes.set_index(keys).index
edges_shortest_route_cost = TIME_EDGES[index_gdf_edges.isin(index_df_nodes)]

## add plot in Folium map
# save first as geojson file
style_edge = {'fillColor': '#00000000', 'color': '#000000'}
edges_shortest_route_cost.geometry.to_file(filename='edges_shortest_route_cost.geojson',
                                 driver='GeoJSON')
folium.GeoJson('edges_shortest_route_cost.geojson', style_function=lambda x: style_edges).add_to((my_map))
my_map.save("shortest_routes_examples.html")


# find shortet path by "VIASAT cost" that is the "time" got from the VIASAT data
init_shortest_OD_path_VIASAT_cost = nx.shortest_path(grafo, O, D, weight='VIASAT_cost')  # using cost (time)
path_VIASAT_cost = ox.plot_route_folium(grafo, init_shortest_OD_path_VIASAT_cost, route_color='green')
path_edges = list(zip(init_shortest_OD_path_VIASAT_cost,init_shortest_OD_path_VIASAT_cost[1:]))
lr = nx.shortest_path_length(grafo, O,D, weight='VIASAT_cost')
lunghezza=[]
for l in path_edges:
  lunghezza.append(grafo [l[0]] [l[1]] [0]['length'])  # get only the length for each arch between 2 path edges, [0] it the key = 0
print("km:{0:.3f} h:{1:.3f} vm:{2:.0f}".format(sum(lunghezza)/1000, lr/3600, sum(lunghezza)/1000/lr*3600))  # units == km
path_VIASAT_cost.save('OD_VIASAT_shortest_path_cost.html')

# add shortest path (by "VIASAT cost" to the my_map
df_nodes = pd.DataFrame(path_edges)
df_nodes.columns = ['u', 'v']

# filter 'TIME_EDGES' with 'df_nodes'
keys = list(df_nodes.columns.values)
index_gdf_edges = TIME_EDGES.set_index(keys).index
index_df_nodes = df_nodes.set_index(keys).index
edges_shortest_route_VIASAT_cost = TIME_EDGES[index_gdf_edges.isin(index_df_nodes)]

## add plot in Folium map
# save first as geojson file
style_VIASAT = {'fillColor': '#00000000', 'color': '#ff0000'}
edges_shortest_route_VIASAT_cost.geometry.to_file(filename='edges_shortest_route_VIASAT_cost.geojson',
                                 driver='GeoJSON')
folium.GeoJson('edges_shortest_route_VIASAT_cost.geojson', style_function=lambda x: style_VIASAT).add_to((my_map))
my_map.save("shortest_routes_examples.html")



'''
## chose one u,v pair (link) in the initial shortest path
## this is the link that will be closed by adding a penalty
AAA = pd.DataFrame(edges_matched_route_OD)
len(AAA)
# sort values by length
sorted_values = AAA.sort_values('length')
AAA.reset_index(inplace=True)
# select one u,v pair
i = 82
U = AAA.u.iloc[i]
V = AAA.v.iloc[i]
'''

# get an edge that is on the same route....
U = 2811353264
V = 2811352855


os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing')
# close a LINK (u,v pair) by adding sufficiently large penalty M (time in seconds ~ 5 hours = 18000 secs)
for u, v, key, attr in grafo.edges(keys=True, data=True):
    attr['VIASAT_cost_penalty'] = attr.get("VIASAT_cost")
    if u == U and v == V:
        penalty = 18000  # seconds of closure of the link (u,v)
        print("gotta!=============================================================================================")
        # break
        attr['VIASAT_cost_penalty'] = float(attr['VIASAT_cost']) + penalty
        grafo.add_edge(u, v, key, attr_dict=attr)
ox.save_graphml(grafo, filename= 'CATANIA_VIASAT_cost_penalty.graphml')


## load grafo again...
file_graphml = 'CATANIA_VIASAT_cost_penalty.graphml'
grafo = ox.load_graphml(file_graphml)
for u, v, key, attr in grafo.edges(keys=True, data=True):
    if len(attr['VIASAT_cost_penalty']) > 0:
        attr['VIASAT_cost_penalty'] = float(attr.get("VIASAT_cost_penalty"))


# check...
for u, v, key, attr in grafo.edges(keys=True, data=True):
    if u == U and v == V:
        print("gotta!=============================================================================================")
        print(attr['VIASAT_cost_penalty'])
        break

os.chdir('C:\\ENEA_CAS_WORK\\Catania_RAFAEL\\postprocessing\\vulnerability')
# get shortest path again...
init_shortest_OD_path_VIASAT_penalty = nx.shortest_path(grafo, O, D, weight='VIASAT_cost_penalty')  # using cost (time)
path = ox.plot_route_folium(grafo, init_shortest_OD_path_VIASAT_penalty, route_color='green')
path_edges = list(zip(init_shortest_OD_path_VIASAT_penalty,init_shortest_OD_path_VIASAT_penalty[1:]))
lr = nx.shortest_path_length(grafo, O,D, weight='VIASAT_cost_penalty')
lunghezza=[]
for l in path_edges:
  lunghezza.append(grafo [l[0]] [l[1]] [0]['length'])  # get only the length for each arch between 2 path edges, [0] it the key = 0
print("km:{0:.3f} h:{1:.3f} vm:{2:.0f}".format(sum(lunghezza)/1000, lr/3600, sum(lunghezza)/1000/lr*3600))  # units == km
path.save('OD_VIASAT_shortest_path_penalty.html')

gdf_nodes, gdf_edges = ox.graph_to_gdfs(grafo)
# add shortest path (by "VIASAT cost" to the my_map
df_nodes = pd.DataFrame(path_edges)
df_nodes.columns = ['u', 'v']

# filter 'TIME_EDGES' with 'df_nodes'
keys = list(df_nodes.columns.values)
index_gdf_edges = gdf_edges.set_index(keys).index
index_df_nodes = df_nodes.set_index(keys).index
edges_shortest_route_VIASAT_penalty = gdf_edges[index_gdf_edges.isin(index_df_nodes)]

## add plot in Folium map
# save first as geojson file
style_VIASAT_penalty = {'fillColor': '#00000000', 'color': '#0000ff'}
edges_shortest_route_VIASAT_penalty.geometry.to_file(filename='edges_shortest_route_VIASAT_penalty.geojson',
                                 driver='GeoJSON')
folium.GeoJson('edges_shortest_route_VIASAT_penalty.geojson', style_function=lambda x: style_VIASAT_penalty).add_to((my_map))
my_map.save("shortest_routes_examples.html")


#################################################################################
#################################################################################
#################################################################################
#################################################################################


# route = nx.shortest_path(grafo, O, D, weight='length')
# path_edges = list(zip(route, route[1:]))
# # print(path_edges)
# all_matched_edges.append(path_edges)
# matched_route.append(route)